[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Approaching Data Structure and Algorithms",
    "section": "",
    "text": "Preface\nSolving optimization problems is my passion, but in my work, building mathematical models typically doesn’t take much time. Instead, I spend most of my time implementing and fine-tuning various algorithms to solve real-world problems. I take great pleasure in transforming optimization models into software products, which requires proficient coding skills.\nJava used to be my favorite programming language, but now Python is my second favorite, especially as I delve deeper into machine learning projects in recent years. I created this personal notebook to document my journey in improving my skills in data structures and algorithms, as well as to continue honing my Java and Python expertise.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Interesting Algorithms",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#two-pointers",
    "href": "intro.html#two-pointers",
    "title": "1  Introduction",
    "section": "1.2 Two Pointers",
    "text": "1.2 Two Pointers\n\n27. Remove Element\n26. Remove Duplicates from Sorted Array\n1. Two Sum\n15. 3Sum\n18. 4Sum\n283. Move Zeroes\n844. Backspace String Compare\n977. Squares of a Sorted Array\n344. Reverse String\n151. Reverse Words in a String\n206. Reverse Linked List\n19. Remove Nth Node From End of List\n160. Intersection of Two Linked Lists\n142. Linked List Cycle II\n2. Add Two Numbers\n217. Contains Duplicate\n53. Maximum Subarray\n9. Palindrome Number\n13. Roman to Integer",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#sliding-window",
    "href": "intro.html#sliding-window",
    "title": "1  Introduction",
    "section": "1.3 Sliding Window",
    "text": "1.3 Sliding Window",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#binary-search",
    "href": "intro.html#binary-search",
    "title": "1  Introduction",
    "section": "1.4 Binary Search",
    "text": "1.4 Binary Search\n\n704. Binary Search\n278. First Bad Version\n1011. Capacity To Ship Packages Within D Days\n2187. Minimum Time to Complete Trips\n875. Koko Eating Bananas\n34. Find First and Last Position of Element in Sorted Array\n74. Search a 2D Matrix\n153. Find Minimum in Rotated Sorted Array\n33. Search in Rotated Sorted Array\n981. Time Based Key-Value Store\n4. Median of Two Sorted Arrays\n2089. Find Target Indices After Sorting Array",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#tree",
    "href": "intro.html#tree",
    "title": "1  Introduction",
    "section": "1.5 Tree",
    "text": "1.5 Tree",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#backtracking",
    "href": "intro.html#backtracking",
    "title": "1  Introduction",
    "section": "1.6 Backtracking",
    "text": "1.6 Backtracking",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#dynamic-programming",
    "href": "intro.html#dynamic-programming",
    "title": "1  Introduction",
    "section": "1.7 Dynamic Programming",
    "text": "1.7 Dynamic Programming",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "moore-voting-algorithm.html",
    "href": "moore-voting-algorithm.html",
    "title": "2  Boyer-Moore Majority Voting Algorithm",
    "section": "",
    "text": "2.1 Leetcode Problems",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Boyer-Moore Majority Voting Algorithm</span>"
    ]
  },
  {
    "objectID": "moore-voting-algorithm.html#leetcode-problems",
    "href": "moore-voting-algorithm.html#leetcode-problems",
    "title": "2  Boyer-Moore Majority Voting Algorithm",
    "section": "",
    "text": "169. Majority Element",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Boyer-Moore Majority Voting Algorithm</span>"
    ]
  },
  {
    "objectID": "moore-voting-algorithm.html#implementations",
    "href": "moore-voting-algorithm.html#implementations",
    "title": "2  Boyer-Moore Majority Voting Algorithm",
    "section": "2.2 Implementations",
    "text": "2.2 Implementations\nBelow is an Java implementation of the algorithm.\npublic int findMajorityElement(int[] nums) {\n    // First Pass to find the candidate\n    int candidate = 0;\n    int count = 0;\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n            count = 1;\n        } else if (num == candidate) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n\n    // Second Pass to verify if the candidate is the majority element\n    count = 0;\n    for (int num : nums) {\n        if (num == candidate) {\n            count++;\n        }\n    }\n\n    // If the candidate is indeed the majority element\n    if (count &gt; nums.length / 2) {\n        return candidate;\n    } else {\n        throw new IllegalArgumentException(\"No majority element found\");\n    }\n}",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Boyer-Moore Majority Voting Algorithm</span>"
    ]
  },
  {
    "objectID": "gcd-euclidean-algorithm.html",
    "href": "gcd-euclidean-algorithm.html",
    "title": "3  Greatest Common Divisor and Least Common Multiple",
    "section": "",
    "text": "3.1 Leetcode Problems",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Greatest Common Divisor and Least Common Multiple</span>"
    ]
  },
  {
    "objectID": "gcd-euclidean-algorithm.html#leetcode-problems",
    "href": "gcd-euclidean-algorithm.html#leetcode-problems",
    "title": "3  Greatest Common Divisor and Least Common Multiple",
    "section": "",
    "text": "1979. Find Greatest Common Divisor of Array\n1201. Ugly Number III",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Greatest Common Divisor and Least Common Multiple</span>"
    ]
  },
  {
    "objectID": "gcd-euclidean-algorithm.html#example",
    "href": "gcd-euclidean-algorithm.html#example",
    "title": "3  Greatest Common Divisor and Least Common Multiple",
    "section": "3.2 Example",
    "text": "3.2 Example\nLet’s take two integers, say 24 and 36:\n\nThe factors of 24 are: 1, 2, 3, 4, 6, 8, 12, 24.\nThe factors of 36 are: 1, 2, 3, 4, 6, 9, 12, 18, 36.\nThe common factors are: 1, 2, 3, 4, 6, 12.\n\nOut of these, the greatest one is 12. So, the GCD of 24 and 36 is 12.",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Greatest Common Divisor and Least Common Multiple</span>"
    ]
  },
  {
    "objectID": "gcd-euclidean-algorithm.html#euclidean-algorithm",
    "href": "gcd-euclidean-algorithm.html#euclidean-algorithm",
    "title": "3  Greatest Common Divisor and Least Common Multiple",
    "section": "3.3 Euclidean Algorithm",
    "text": "3.3 Euclidean Algorithm\nThe Euclidean algorithm is a well-known method for finding the GCD of two numbers. It is based on the principle that the GCD of two numbers also divides their difference. Here’s how it works:\n\nGiven two numbers a and b, replace a with b and b with the remainder of the division of a by b (a % b).\nRepeat this process until b becomes 0.\nThe GCD is the non-zero number remaining.",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Greatest Common Divisor and Least Common Multiple</span>"
    ]
  },
  {
    "objectID": "gcd-euclidean-algorithm.html#steps-in-the-euclidean-algorithm",
    "href": "gcd-euclidean-algorithm.html#steps-in-the-euclidean-algorithm",
    "title": "3  Greatest Common Divisor and Least Common Multiple",
    "section": "3.4 Steps in the Euclidean Algorithm",
    "text": "3.4 Steps in the Euclidean Algorithm\nFor example, let’s find the GCD of 48 and 18 using the Euclidean algorithm:\n\nInitial values: a = 48, b = 18.\nCompute 48 % 18, which is 12. Update a to 18 and b to 12.\nCompute 18 % 12, which is 6. Update a to 12 and b to 6.\nCompute 12 % 6, which is 0. Update a to 6 and b to 0.\nNow, b is 0, so the GCD is the current value of a, which is 6.\n\nIn summary, the GCD of two integers is the largest integer that divides both of them without leaving a remainder, and it can be efficiently computed using the Euclidean algorithm.",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Greatest Common Divisor and Least Common Multiple</span>"
    ]
  },
  {
    "objectID": "gcd-euclidean-algorithm.html#implementations",
    "href": "gcd-euclidean-algorithm.html#implementations",
    "title": "3  Greatest Common Divisor and Least Common Multiple",
    "section": "3.5 Implementations",
    "text": "3.5 Implementations\nBelow is an implementation of the algorithm in Java:\n// Function to return the greatest common divisor of a and b\npublic long gcd(long a, long b) {\n    // Continue the loop until b becomes 0\n    while (b != 0) {\n        // Swap a with b and b with the remainder of a divided by b\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    // The GCD is stored in a\n    return a;\n}",
    "crumbs": [
      "Special Algorithms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Greatest Common Divisor and Least Common Multiple</span>"
    ]
  },
  {
    "objectID": "two-pointers.html",
    "href": "two-pointers.html",
    "title": "4  Two Pointers",
    "section": "",
    "text": "27. Remove Element\n26. Remove Duplicates from Sorted Array\n1. Two Sum\n15. 3Sum\n18. 4Sum\n283. Move Zeroes\n844. Backspace String Compare\n977. Squares of a Sorted Array\n344. Reverse String\n151. Reverse Words in a String\n206. Reverse Linked List\n19. Remove Nth Node From End of List\n160. Intersection of Two Linked Lists\n142. Linked List Cycle II\n2. Add Two Numbers\n217. Contains Duplicate\n53. Maximum Subarray\n9. Palindrome Number\n13. Roman to Integer",
    "crumbs": [
      "Two Pointers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Two Pointers</span>"
    ]
  },
  {
    "objectID": "binary-search.html",
    "href": "binary-search.html",
    "title": "6  Binary Search",
    "section": "",
    "text": "6.1 Questions",
    "crumbs": [
      "Binary Search",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Binary Search</span>"
    ]
  },
  {
    "objectID": "binary-search.html#questions",
    "href": "binary-search.html#questions",
    "title": "6  Binary Search",
    "section": "",
    "text": "6.1.1 Fully sorted array\n\n704. Binary Search\n278. First Bad Version\n2187. Minimum Time to Complete Trips\n69. Sqrt(x)\n35. Search Insert Position\n1482. Minimum Number of Days to Make m Bouquets\n668. Kth Smallest Number in Multiplication Table\n719. Find K-th Smallest Pair Distance\n1201. Ugly Number III\n34. Find First and Last Position of Element in Sorted Array\n74. Search a 2D Matrix\n153. Find Minimum in Rotated Sorted Array\n981. Time Based Key-Value Store\n4. Median of Two Sorted Arrays\n2089. Find Target Indices After Sorting Array\n\n\n\n6.1.2 Nearly sorted array\n\n33. Search in Rotated Sorted Array\n81. Search in Rotated Sorted Array II\n153. Find Minimum in Rotated Sorted Array\n154. Find Minimum in Rotated Sorted Array II\n162. Find Peak Element\n852. Peak Index in a Mountain Array\n\nMin-max\n\n410. Split Array Largest Sum\n875. Koko Eating Bananas\n1011. Capacity To Ship Packages Within D Days\n1283. Find the Smallest Divisor Given a Threshold",
    "crumbs": [
      "Binary Search",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Binary Search</span>"
    ]
  },
  {
    "objectID": "binary-search.html#reference",
    "href": "binary-search.html#reference",
    "title": "6  Binary Search",
    "section": "6.2 Reference",
    "text": "6.2 Reference\n\nhttps://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems\nBinary Search 101 The-Ultimate-Binary-Search-Handbook",
    "crumbs": [
      "Binary Search",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Binary Search</span>"
    ]
  }
]